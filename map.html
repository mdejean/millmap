<!doctype html>
<html>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css">
 <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
 <script src="proj4.js"></script>
 <script src="json_table.js"></script>
 <style type='text/css'>
 #map { height: 800px; }
 </style>
 <script>
proj4.defs('FIPS:3104','+proj=lcc +lat_1=40.66666666666666 +lat_2=41.03333333333333 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +ellps=GRS80 +datum=NAD83 +to_meter=0.3048006096012192 +no_defs ');

function point_to_latlng(p) {
    p.x = Number.parseInt(p.x);
    p.y = Number.parseInt(p.y);
    p = proj4('FIPS:3104', 'WGS84', p);
    return L.latLng(p.y, p.x);
}

function points_to_polyline(points) {
    lls = [];
    for (let point of points) {
        lls.push(point_to_latlng(point));
    }
    return L.polyline(lls);;
}


options = {
  year: 'numeric', month: 'short', day: 'numeric', weekday: 'long', timeZone: 'UTC'
};
var date_formatter = new Intl.DateTimeFormat('en-US', options);

function format_date(s) {
    return date_formatter.format(new Date(Number.parseInt(s) * 1000))
}

function popup(action) {
    let s = "";
    s += format_date(action.action_date);
    s += "<br>";
    if (action.is_milling) {
        s += "<b>Milling</b>";
    } else {
        s += "<b>Paving</b>";
    }
    s += "<br>";
    s += action.on_street;
    s += "<br>(";
    s += action.from_street;
    s += " - ";
    s += action.to_street;
    s += ")";
    return s;
}

var map;
var lines;

window.addEventListener('load', function() {
    map = L.map('map');
    lines = L.layerGroup();
    // add an OpenStreetMap tile layer
    L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    fetch('index.php?json').then(function(response) {
        response.json().then(function(a) {
            let segments = new Map();
            let errors = [];
            
            for (let action of a) {
                if ('error_code' in action.points) {
                    let a = action;
                    a.error_code = a.points.error_code;
                    a.error_message = a.points.error_message;
                    a.points = [];
                    delete a.points;
                    errors.push(a);
                } else {
                    for (let i = 0; i < action.points.length - 1; i++) {
                        if (action.points[i] < action.points[i+1]) {
                            p1 = action.points[i];
                            p2 = action.points[i+1];
                        } else {
                            p1 = action.points[i+1];
                            p2 = action.points[i];
                        }
                        let key = p1.x + p1.y + p2.x + p2.y;
                        if (!segments.has(key)) {
                            segments.set(key, {points: [p1, p2], actions: []})
                        }
                        segments.get(key).actions.push({
                                action_date: action.action_date, 
                                is_milling: action.is_milling, 
                                on_street: action.on_street, 
                                from_street: action.from_street, 
                                to_street: action.to_street
                            });
                    }
                }
            }
            
            //draw each street segment with the most recent action
            for (let v of segments.values()) {
                let line = points_to_polyline(v.points);
                v.actions.sort((a, b) => a.action_date > b.action_date);
                let action = v.actions[0];
                
                if (action.is_milling && action.action_date >= Date.now()/1000) {
                    line.setStyle({weight: 1, color: 'red', dashArray: '1 10'});
                } else if (action.is_milling) {
                    line.setStyle({weight: 1, color: 'red'});
                } else if (action.action_date >= Date.now()/1000) {
                    line.setStyle({weight: 1, color: 'blue', dashArray: '1 10'});
                } else {
                    line.setStyle({weight: 1, color: 'blue'});
                }
                
                line.bindPopup(popup(action));
                line.addTo(lines);
            }
            lines.addTo(map);
            
            document.getElementById('errors').appendChild(
                buildHtmlTable(errors, {
                        'action_date': d => document.createTextNode(format_date(d))
                    })
                );
        });
    });
    
    map.on('zoomend', function() {
        lines.eachLayer(function(layer) {
            if (layer.options.dashArray) {
                layer.setStyle({dashArray: Math.pow(2, map.getZoom()) / 1.5e6 * 200});
                layer.setStyle({dashOffset: Math.pow(2, map.getZoom()) / 1.5e6 * 100});
            }
            if (map.getZoom() > 15) {
                layer.setStyle({weight: Math.pow(2, map.getZoom()) / 1.5e6 * 50});
            } else if (map.getZoom() > 12) {
                layer.setStyle({weight: 2});
            } else {
                layer.setStyle({weight: 1});
            }
        });
    });
    map.setView([40.7358,-73.9243], 10);
    
    
});
 </script>
</head>
<body>
 <div id="map"></div>
 <div id="errors">Errors this run:<br></div>
</body>
</html>